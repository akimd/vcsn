* 2012-12-26
** dyn: input/output
Routines: dyn::read_(automaton|ratexp)_(file|string) and dyn::print take the
input format.

The format is described by an argument of type vcsn::dyn::FileType. Available
input/output are:

- vcsn::dyn::FileType::dotty.
- vcsn::dyn::FileType::text.
- vcsn::dyn::FileType::xml.

* 2012-12-19
** genset is replaced by labelset
Through out the code.

* 2012-12-18
** dyn: input
New routines: dyn::read_(automaton|ratexp)_(file|string).

** dyn: output
New routines: dyn::print, for both automata and RatExps.

** bin: new tools
vcsn-cat, vcsn-transpose (both on RatExps only currently).
vcsn-standard-of.
vcsn-lift.

* 2012-12-13
** krat -> rat
kratexp, kratexpset etc. are renamed as ratexp, ratexpset, etc.

** labels are unit
labels-are-empty/lae were mapped to labels-are-unit/lau.

* 2012-10-31
** dyn::context
For consistency with dyn::automaton, vcsn::ctx::abstract_context is renamed
vcsn::dyn::context.  Eventually, we might turn it into a shared pointer too.

** dyn::de_bruijn, bin/vcsn-de-bruijn
New tools, useful for tests for instance.

  $ vcsn-de-bruijn char_b_lal 2
  digraph
  {
    vcsn_context = "char_b_lal"
    vcsn_genset = "ab"
    rankdir = LR
    node [shape = circle]
    {
      node [style = invis, shape = none, label = "", width = 0, height = 0]
      I1
      F4
    }
    I1 -> 1
    1 -> 1 [label = "a + b"]
    1 -> 2 [label = "a"]
    2 -> 3 [label = "a + b"]
    3 -> 4 [label = "a + b"]
    4 -> F4
  }

* 2012-10-22
** dyn::parse_file and parse_string
They construct dyn::automaton's.

** dyn::eval
For bad reasons, currently works only for char_b_lal

** vcsn-determinize and vcsn-evaluate
Two new shell commands to write tests.

* 2012-10-12
** pprat works with abstract algorithms
pprat now uses *only* abstract (aka, dynamic) algorithms!  On OS X, it is
now a 77KB program; it was 11MB before.

This schedules its death: either it will be replaced by a set of smaller
grain commands (vcsn-determinize, vcsn-standard-of, etc.) from which test
cases will be easier to write, or it will be replaced by some early
implementation of a TAF-Kit-like *unified* program (instead of one per
context).

* 2012-10-09
** automata provide a vname
To dispatch algorithms such as dotty, we not only need to know the context
type name, but also the automaton type name, as mutable_automaton and
transpose_automaton are two different types for instance.

* 2012-10-08
** dot-parser
Because it uses only algorithms made abstract (make_context,
make_automaton_editor, and dotty), the dot parser now works for any of the
precompiled contexts!

* 2012-09-26
** add_entry
In addition to the add_entry method of mutable_automaton, there is now an
add_entry _algorithm_, which is templated by the automaton type.  This
algorithm provides an abstract interface to an unknown type of automaton.

* 2012-09-24
** renamings
For consistency, polynomials is renamed polynomialset.

** mutable_automaton::add_entry and del_entry
The first of these new functions allows to add directly a list of transition
between two states by passing the corresponding entry_t (this is most useful
when reading an automaton with entries, such as with the Dot parser).  The
second one removes every existing transition between two states.

* 2012-08-01
** labels are empty
Initial work on labels-are-empty automata.  See the unit/char_z_lae test.
The labels are not displayed, but the "{...}" to denote the weights, are
kept:

  digraph
  {
    vcsn_context=char_z_lae
    vcsn_genset=""
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F2
    }
    I1 -> 1
    2 -> F2 [label="{10}"]
    1 -> 2 [label="{51}"]
    2 -> 3 [label="{3}"]
    2 -> 1
    1 -> 1 [label="{42}"]
    1 -> 3
  }

In that case, the transitions do not store labels.

** lift now returns a labels-are-empty automaton/ratexp
Accordingly, pprat -l (lift) now displays:

  $ pprat -Lw -l 'ab+cd'
  digraph
  {
    vcsn_context=char_kratexpset<char_b_law>_lae
    vcsn_genset="abcd"
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F2
      F3
    }
    1 -> 2 [label="{ab}"]
    2 -> F2
    I1 -> 1
    3 -> F3
    1 -> 3 [label="{cd}"]
  }

* 2012-07-31
** dot-parser
It is now possible to load an automaton from its dotty output.  Actually, it
is possible to write simpler automata.  This is no yet fully generic: it
works properly only for char_b_lal.

The test program unit/parse-dot gives access to it.  When fed with the
following input file:

  digraph
  {
    vcsn_context=char_b_lal vcsn_genset="a"
    {1} -> {2 3} -> {4 5 6} [label=a]
    I -> 1
    {4 5 6} -> F
  }

it produces an automaton, and dumps it using the dotty algorithm:

  digraph
  {
    vcsn_context=char_b_lal
    vcsn_genset="a"
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F4
      F5
      F6
    }
    1 -> 2 [label="a"]
    1 -> 3 [label="a"]
    2 -> 4 [label="a"]
    2 -> 5 [label="a"]
    2 -> 6 [label="a"]
    3 -> 4 [label="a"]
    3 -> 5 [label="a"]
    3 -> 6 [label="a"]
    I1 -> 1
    4 -> F4
    5 -> F5
    6 -> F6
  }

* 2012-07-25
** pprat uses -L for labels instead of -A
For consistency, since we now also use the name "labels" to denote the
leaves of rational expressions (others that \z and \e), -A is renamed -L.

** Metadata are embedded in the Dot file
The pseudo name "A" which was used in every dotty output is no longer
defined, as it is both optional and useless.  The context name and the
alphabet are also provided.  For instance:

  $ ./tests/unit/ladybird-b 2 | sed 4q
  digraph
  {
    vcsn_context=char_b_lal
    vcsn_genset="abc"
  $ pprat -s -L z 'abc' | sed 4q
  digraph
  {
    vcsn_context=char_z_lal
    vcsn_genset="abcd"
  $ pprat -s -L zr -A w 'abc' | sed 4q
  digraph
  {
    vcsn_context=char_kratexpset<char_z_law>_law
    vcsn_genset="abcd"

This is an experimentation, and the current choice is somewhat
unsatisfactory.  Instead of

    vcsn_context=char_b_lal
    vcsn_genset="abc"

it is probably more sensible to use

    vcsn_context="char_b_lal{abc}"

or maybe

    vcsn_context="char{abc}_b_lal"

so that when weightsets depend for instance upon an alphabet, it can be
specified too.  Instead of

    vcsn_context=char_kratexpset<char_z_law>_law
    vcsn_genset="abcd"

(which does not define the alphabet used for the weightset), one would
expect:

    vcsn_context=char_kratexpset<char_z_law{xyz}>_law{abcd}

or maybe

    vcsn_context=char{abcd}_kratexpset<char{xyz}_z_law>_law

Also, the name "kratexpset" is of course open to discussion:

    vcsn_context=char_rat<char_z_laz{xyw}>_law{abcd}

** polynomials::conv
It is now possible to read back polynomials such as "a+b+{2}a".

** static_assert
It is used more extensively to forbid meaningless calls, such as
determinizing a law automaton.

* 2012-07-13
** Precompiled contexts
Several predefined contexts come with their own header (e.g.,
"ctx/char_b_lal"), and their own library (e.g., "libchar_b_lal").  This is
provide for char_{b,z,zmin}_{lal,law}.

** z_min renamed zmin
Consistently with Vaucanson 1.4.

* 2012-07-10
** transposition
Transposition on automaton is a read/write view: operations such as
del_state, add_transition, etc. on a transposed automaton actually modify
the wrapped automaton: set_final calls set_initial and so forth.

As an extreme example, the following snippet:

  using context_t = vcsn::ctx::char_b;
  using automaton_t = vcsn::mutable_automaton<context_t>;
  using tr_automaton_t = vcsn::details::transpose_automaton<automaton_t>;
  context_t ctx{{'a', 'b'}};
  auto ks = ctx.make_kratexpset();
  auto aut = vcsn::standard_of<tr_automaton_t>(ctx, ks.conv("a+a+a+a"));

applies the standard-of algorithm to a transposed mutable_automaton.  In
other words,

  aut.original_automaton();

is the transposition of a standard automaton, except that it is a
mutable_automaton, not a transpose_automaton<mutable_automaton>.

* 2012-07-09
** transposition
The "transpose" operation is implemented on words, weights, kratexps, and
automata.  pprat provides support to transpose on kratexps (option -t):

  pprat -W zrr -t {{{2}ab}cd}abcd   =>   {{{2}ba}dc}dcba
  pprat -W zrr -t {ab}(abcd)*{cd}   =>   ({dc}(dcba)*{ba})

and on (standard) automata (option -T):

  $ pprat -A w -W br    -s '{ab}(\e+a+b({abc}c{bcd})*){cd}' > forward.dot
  $ pprat -A w -W br -T -s '{ab}(\e+a+b({abc}c{bcd})*){cd}' > transpose.dot
  $ diff -W80 -t  -y forward.dot transpose.dot
  digraph A {                            digraph A {
    rankdir=LR                             rankdir=LR
    node [shape=circle]                    node [shape=circle]
    {                                      {
      node [style=invis,shape=none,la        node [style=invis,shape=none,la
      I1                                     I1
                                      >      I2
                                      >      I4
      F1                                     F1
      F2                              <
      F4                              <
    }                                      }
    1 -> F1 [label="{(ab).(cd)}"]     |    I1 -> 1 [label="{(dc).(ba)}"]
    I1 -> 1                           |    1 -> F1
    2 -> F2 [label="{cd}"]            |    I2 -> 2 [label="{dc}"]
    1 -> 2 [label="{ab}a"]            |    2 -> 1 [label="{ba}a"]
    4 -> F4 [label="{cd}"]            |    I4 -> 4 [label="{dc}"]
    4 -> 4 [label="{(abc).(bcd)}c"]   |    4 -> 4 [label="{(dcb).(cba)}c"]
    1 -> 3 [label="{ab}b"]            |    3 -> 1 [label="{ba}b"]
    3 -> 4 [label="{(abc).(bcd)}c"]   |    4 -> 3 [label="{(dcb).(cba)}c"]
  }                                      }

* 2012-06-19
** aut_to_exp
An initial version of aut_to_exp is available.  The new pprat option -a
provides an access to this algorithm: apply aut_to_exp to the standard_of an
expression.

  pprat      -a 'a*'     => \e+(a.(a*))
  pprat      -a '(a+b)c' => (a.c)+(b.c)
  pprat -W z -a '{2}({3}a+{5}b){7}c{11}' => (({6}a.{7}c)+({10}b.{7}c)){11}

Currently, the only "heuristic" implemented eliminates the states in order.
There are probably possible improvements.

  pprat -a '(a+b)*' | wc -c => 265

** pprat: -a and -w are renamed -A and -W

** new factory: de Bruijn
Builds automata for (a+b)a(a+b)^n.

* 2012-06-18
** standard_of is part of vcsn::
It used to be in vcsn::rat::.

* 2012-06-14
** kratexpset/abstract_kratexpset
kratexpset, i.e. the object that provides operation on kratexps (with
specified Gen and Weight), used to derive from abstract_kratexp (which is
"opaque": it does not know the precise type that is used underneath).

Now, from abstract_kratexp we derive a concrete_abstract_kratexpset
which *agreggates* a kratexpset.  This means that kratexpset no longer
derives from a weakly-typed ancestor, and can provide simple and
strongly-typed routines.

** kratexpset/kratexp
For consistency with weightset/weight, genset/gen, kratexps (note the s) is
renamed as kratexpset and std::shared_ptr<const rat::node> as kratexp.

** lift
A new algorithm which creates, from an automaton, another one with the same
states and transitions, but the new automaton features only spontaneous
transitions, whose weights correspond to the labels (and weights) of the
initial one.

For instance:

  $ pprat -aw -wz  -sl '({2}\e+{3}a){4}'
  digraph A {
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F1
      F2
    }
    1 -> F1 [label="{8}"]
    I1 -> 1
    2 -> F2 [label="{4}"]
    1 -> 2 [label="{3}a"]
  }

  digraph A {
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F1
      F2
    }
    1 -> F1 [label="{{8}\\e}"]
    I1 -> 1
    2 -> F2 [label="{{4}\\e}"]
    1 -> 2 [label="{{3}a}\\e"]
  }

** RatExps: fix is_unit
is_unit simply checked that the expression was \e, but did not check that
weight itself was the unit.

** VCSN_DEBUG
This variable allows to force the display of weights.

* 2012-06-11
** Contexts aggregate shared pointers
Now contexts are mutable, and hold (shared) pointers to (immutable) gensets
and weightsets.  This way, we can alter contexts (e.g., the ladybird factory
can add the letters it needs in a new genset), yet there is good sharing,
and identity can still be used to distinguish, for instance, two gensets
defined equally.

It is also simpler to really expose them as pointers, so every
"weightset().mul", etc. must be rewritten as "weightset()->mul".

* 2012-06-08
** Contexts
The Kind parameter is now part of the context.  The same type of Kind is now
use for both RatExps and automata.  This results in many significant
simplifictions.

For instance, again, the test case for product:

Before:

   using context_t = vcsn::ctx::char_z;
   context_t ctx { {'a', 'b', 'c'} };
   using automaton_t =
     vcsn::mutable_automaton<context_t, vcsn::labels_are_letters>;
   automaton_t aut1(ctx);

After:

  using context_t = vcsn::ctx::char_z;
  context_t ctx { {'a', 'b', 'c'} };
  using automaton_t = vcsn::mutable_automaton<context_t>;

Or the source of pprat:

Before:

  using atom_kind_t
    = typename Factory::kind_t;
  using label_kind_t
    = typename vcsn::label_kind<atom_kind_t>::type;
  using context_t =
    vcsn::ctx::context<typename Factory::genset_t,
                       typename Factory::weightset_t,
                       label_kind_t>;
  context_t ctx{factory.genset(), factory.weightset()};
  using automaton_t = vcsn::mutable_automaton<context_t>;
  auto aut = vcsn::rat::standard_of<automaton_t>(ctx, e);

After:

  using context_t = typename Factory::context_t;
  using automaton_t = vcsn::mutable_automaton<context_t>;
  auto aut = vcsn::rat::standard_of<automaton_t>(factory.context(), e);


* 2012-06-05
** Contexts
"Contexts" were introduced to factor two aspects that are required through
out the library: the GenSet type (i.e., the nature of the generators), and
the WeightSet type (i.e., the nature of the weights).  Not only do contexts
define these types, they must also be instantiated so that "run-time"
details be known: for instance the set of generators is dynamic (what are
the allowed letters), and on occasion the weightset also needs run-time
information (e.g., when RatExp are parameterized by RatExp, what is the
alphabet of the latter ones?).

As an example of the changes on the user side, consider the product
test-case.

Before:

   typedef vcsn::set_alphabet<vcsn::char_letters> alpha_t;
   typedef vcsn::mutable_automaton<alpha_t, vcsn::z,
                                  vcsn::labels_are_letters> automaton_t;
   vcsn::z z;
   alpha_t alpha{'a', 'b', 'c'};
   automaton_t aut1(alpha, z);

After:

   using context_t = vcsn::ctx::char_z;
   context_t ctx { {'a', 'b', 'c'} };
   using automaton_t =
     vcsn::mutable_automaton<context_t, vcsn::labels_are_letters>;
   automaton_t aut1(ctx);

* 2012-05-30
** RatExp: atoms are words
Expressions such as "(ab)(ab)" used to be equivalent to "(abab)" (a
single four-letter atom).  Now:

  pprat -aw '(ab)(ab)'   => (ab).(ab)
  pprat -aw 'abab'       => abab
  pprat -aw 'ab.ab'      => (ab).(ab)
  pprat -aw 'ab(ab)abc*' => (ab).(ab).(ab).(c*)

* 2012-05-28
** New algorithm: eval, evaluates a word over an (weighted) automaton
Defined in vcsn/algos/eval.hh as vcsn::eval.

** New algorithm: determinize, Boolean automaton determinization
Defined in vcsn/algos/determinize.hh as vcsn::determinize.

* 2012-05-25
** RatExp: changes in the display
Fixed the output of "atoms are words" expressions.  For instance
"(ab)*" used to be displayed as "ab*" (which is wrong as it is parsed
as "a(b*)").  It is now properly displayed as "(ab)*".

** RatExp: slight changes in the grammar
A star is now valid after a weight:

  $ pprat -w z '{2}ab{3}*'
  ({2}(a.b){3})*

* 2012-05-11
** dotty: define initial/final states first
In order to improve readibility, instead of

  digraph A {
    rankdir=LR
    node [shape=circle];
    F1 [style=invis,shape=none,label="",width=0,height=0]
    1 -> F1 [label="{a.a.((d.d)*)}"]
    3 -> 2 [label="{(d.d)*}b"]
    I1 [style=invis,shape=none,label="",width=0,height=0]
    I1 -> 1
    1 -> 2 [label="{a.a.((d.d)*)}b"]
    F3 [style=invis,shape=none,label="",width=0,height=0]
    3 -> F3 [label="{(d.d)*}"]
    2 -> 3 [label="b"]
  }

we now produce

  digraph A {
    rankdir=LR
    node [shape=circle]
    {
      node [style=invis,shape=none,label="",width=0,height=0]
      I1
      F1
      F3
    }
    1 -> F1 [label="{a.a.((d.d)*)}"]
    3 -> 2 [label="{(d.d)*}b"]
    I1 -> 1
    1 -> 2 [label="{a.a.((d.d)*)}b"]
    3 -> F3 [label="{(d.d)*}"]
    2 -> 3 [label="b"]
  }

* 2012-05-10
** RatExp: support for the kind of atoms
As a major overhaul, the rational expressions (vcsn::rat::node) are
now parameterized by Atom, which denotes the atom value.  The kratexps
structure is now parameterized by the Kind, from which it is deduced,
from the GenSet parameter, whether we should use word_t or letter_t
atoms.

** pprat: an option -a
To provide user-access to these feature, pprat now supports an option
-a, which accepts "letters" or "words" as argument, with obvious
meaning.  For instance:

  pprat -a letters 'abc' => a.b.c
  pprat -a letters 'abc.abc' => a.b.c.a.b.c
  pprat -w br -al '{aa}bb{c}dd{a}' => ({a.a}(b.b).{c}(d.d)){a}

  pprat -a words 'abc' => abc
  pprat -a words 'abc.abc' => abc.abc
  pprat -w br -aw '{aa}bb{c}dd{a}' => ({aa}bb.{c}dd){a}

Of course, this also works with the "standard-of" option:

  $ pprat -w br -al '{aa}({dd}\e+bb)*'
  {a.a}(({d.d}\e+(b.b))*)
  $ pprat -s -w br -al '{aa}({dd}\e+bb)*'
  digraph A {
    rankdir=LR
    node [shape=circle];
    F1 [style=invis,shape=none,label="",width=0,height=0]
    1 -> F1 [label="{a.a.((d.d)*)}"]
    3 -> 2 [label="{(d.d)*}b"]
    I1 [style=invis,shape=none,label="",width=0,height=0]
    I1 -> 1
    1 -> 2 [label="{a.a.((d.d)*)}b"]
    F3 [style=invis,shape=none,label="",width=0,height=0]
    3 -> F3 [label="{(d.d)*}"]
    2 -> 3 [label="b"]
  }

versus:

  $ pprat  -w br -aw '{aa}({dd}\e+bb)*'
  {aa}(({dd}\e+bb)*)
  $ pprat -s -w br -aw '{aa}({dd}\e+bb)*'
  digraph A {
    rankdir=LR
    node [shape=circle];
    F1 [style=invis,shape=none,label="",width=0,height=0]
    1 -> F1 [label="{aa.(dd*)}"]
    2 -> 2 [label="{dd*}bb"]
    F2 [style=invis,shape=none,label="",width=0,height=0]
    2 -> F2 [label="{dd*}"]
    1 -> 2 [label="{aa.(dd*)}bb"]
    I1 [style=invis,shape=none,label="",width=0,height=0]
    I1 -> 1
  }


* 2012-05-07
** RatExp: in some case the weights could be lost
"Associativity" was applied too eagerly, which would result in loss of
some weights.  E.g. {a}bb{c}dd resulted in b.b.d.d, not it evaluates
to {a}(b.b).{c}(d.d).

* 2012-05-03
** RatExp: improved pretty-printing
The outermost pair of parentheses is removed if useless.  For
instance:

   (a.b) => a.b
   (a+b+c) => a+b+c
   (a*) => a*

But in the following examples they are kept.

   {3}(a.b){4}
   {3}(a*)
   (a+b){4}

** standard-of: star is fixed
Standard-of seems to be correct.

* 2012-04-25
** Expressions overhaul
They are immutable: we no longer make side effects on expressions.
They are shared_ptr, no longer plain pointers.  They *can* be used
like the other values, by value.

* 2012-04-19
** standard-of is fully implemented
Support for star was implemented, and checked for B and Z.  For
implementation reasons, one cannot yet use rational expressions as
weights.

* 2012-04-18
** mutable_automata::mul_weight

** RatExp::head and tail

** dotty
In order to improve the readability of its output, it no longer
"defines" the reachable states.  See the following diff:

   digraph A {
     rankdir=LR
     node [shape=circle];
  -  1
  -  2
  -  3
  -  4
     I1 [style=invis,shape=none,label="",width=0,height=0]
     I1 -> 1 [label="{6}"]
     F1 [style=invis,shape=none,label="",width=0,height=0]
     1 -> F1
     1 -> 2 [label="a"]
     1 -> 3 [label="a"]
     2 -> 4 [label="{3}b"]
     F4 [style=invis,shape=none,label="",width=0,height=0]
     4 -> F4
     4 -> 3 [label="a"]
   }


** standard-of: many fixes in the handling of the weights
An expression such as "{12}\e" used to leave the weight in the initial
transition; it is now on the final transition.  More generally the
initial transition always has unit as weight.

The product and sum of expressions now handle the left and right
weights.

Accepting initial states in expressions such as "\e+a" are no longer
lost.

* 2012-04-11
** Many renamings
  alphabet_t/alphabet() -> genset_t/genset(), etc.
  factory -> abstract_kratexp.
  factory_ -> kratexp.
  initials() -> initial_transitions(), etc.
  invalid_state -> null_state, etc.
  nb_state() -> num_states(), etc.
  polynomial -> polynomials, etc.

* 2012-04-09
** product

  An implementation of the product of two automata is available.

* 2012-04-07
** z_min

  An example of tropical semiring, to test show_unit().

* 2012-04-05
** char_letters::special()

  This method return a special, reserved character, that is used to
  label initial and final transitions.  This character is not part of
  the alphabet and is never output.

* 2012-04-04
** standard-of
Initial work on "+".

** mutable_automata are implemented using a pre() and post() states

  What is missing is the correct '$' letter on the initial and final
  transitions.  The current value is the default value for label_t.

  The previous interface has been preserved (but maybe we should
  clean it) except for one change:

    initial() and final() have been changed to return a pseudo
    container of transitions.  These transitions give us both
    the weight and the initial/final state.

  The following methods are new:

    pre(), post()         returns the pre-initial and post-final state.
    all_states()          returns all states, including pre() and post()
    all_transitions()     returns all transitions, including initial and
                            final transitions
    all_entries()         likewise for entries
    all_out(s), all_in(s) likewise for outgoing and ingoing transitions


  The methods get_initial_weight(s) and get_final_weight(s) are slower
  now, because they need to locate the corresponding initial/final
  transition.  For the same reason, is_initial(), is_final() are also
  slower.

* 2012-04-03
** standard-of
Initial version of standard-of is implemented.  Can be tested with
pprat's new option -s:

  $ pprat -wz -s '{123}a'
  digraph A {
    rankdir=LR
    node [shape=circle];
    1
    I1 [style=invis,shape=none,label="",width=0,height=0]
    I1 -> 1
    2
    F2 [style=invis,shape=none,label="",width=0,height=0]
    2 -> F2
    1 -> 2 [label="{123}a"]
  }

** mutable_automaton uses unsigned for state_t and transition_t.

This allows to store states in a std::vector<stored_state_t>.
Likewise for transitions.  Erased elements are marked (so they are
skipped over during iteration), and added to a free store to be reused
later.

** mutable_automaton does not store any weight when WeightSet == b.

** mutable_automaton has a read-only entry interface

  entries() is a pseudo container that filters transitions()
    to see each (src,dst) pair at most once.

  entry_at(src, dst) and entry_at(t) return a polynomial describing
    the entry between (src, dst) or (src_of(t), dst_of(t)).

  entryset() returns the WeightSet that can be used to manipulate
    these polynomials.

** make check-rat, make check-unit

There is a check target for each subdirectory of tests/.

* 2012-04-02
** Alphabets are checked
pprat is hard-coded to use a, b, c, d for all the alphabets
(including for inner rational expressions):

  $ pprat -w b -e 'y'
  1.1: invalid word: y: invalid letter: y

** Weights are checked
As follows:

  $ pprat -w b -e '{12}a'
  1.1-5: invalid Boolean: 12

Unfortunately the locations are bad currently for complex weights:

  $ pprat -w zr -e '{x}a'
  1.1-4: 1.1: invalid word: x: invalid letter: x

To be fixed.

* 2012-03-30
** G++ 4.7 is required
We use constructs that are not supported by 4.6 (e.g., constructor
delegation).

** zrr
As a demonstration that rational expressions can be weights of
rational expressions, pprat supports '-w zrr' (Rat<Rat<Z>>):

   $ pprat -w zr -e '{{{2}{3}a}u}x{{{4}{5}\e}\e}'
   {{{120}a}u}x

--
Local Variables:
mode: outline
coding: utf-8
ispell-dictionary: "american"
fill-column: 76
End:
