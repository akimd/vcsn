#! /bin/sh

## ---------------------- ##
## Existing transitions.  ##
## ---------------------- ##

# See the actual code of product to understand the point of this test
# (which is new_transition vs. add_transition).
run 0 '' -vcsn derived-term -e 'a*a' -o 'a*a.gv'
run 0 '' -vcsn product -o prod.gv -f 'a*a.gv' 'a*a.gv'
run 0 'a*a' -vcsn aut-to-exp -f prod.gv


## ---------------------- ##
## (a+b)* x (b+c)* = b*.  ##
## ---------------------- ##

run 0 '' -vcsn standard -C 'lal_char(ab)_b' -e '(a+b)*' -o ab.gv
run 0 '' -vcsn standard -C 'lal_char(bc)_b' -e '(b+c)*' -o bc.gv
run 0 - -vcsn product -f ab.gv bc.gv <<\EOF
digraph
{
  vcsn_context = "lal_char(b)_b"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
    F0
    F1
  }
  {
    node [shape = circle]
    0
    1
  }
  I0 -> 0
  0 -> F0
  0 -> 1 [label = "b"]
  1 -> F1
  1 -> 1 [label = "b"]
}
EOF

## ------------- ##
## ab x cd = 0.  ##
## ------------- ##

run 0 '' -vcsn standard -C 'lal_char(ab)_b' -e 'ab' -o ab.gv
run 0 '' -vcsn standard -C 'lal_char(cd)_b' -e 'cd' -o bc.gv
run 0 - -vcsn product -f ab.gv bc.gv <<\EOF
digraph
{
  vcsn_context = "lal_char_b"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
  }
  {
    node [shape = circle]
    0 [color = DimGray]
  }
  I0 -> 0 [color = DimGray]
}
EOF



## ---------------------- ##
## (a+b)* x (c+d)* = \e.  ##
## ---------------------- ##

run 0 '' -vcsn standard -C 'lal_char(ab)_b' -e '(a+b)*' -o ab.gv
run 0 '' -vcsn standard -C 'lal_char(cd)_b' -e '(c+d)*' -o bc.gv
run 0 - -vcsn product -f ab.gv bc.gv <<\EOF
digraph
{
  vcsn_context = "lal_char_b"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
    F0
  }
  {
    node [shape = circle]
    0
  }
  I0 -> 0
  0 -> F0
}
EOF



## ------------ ##
## lal_char_z.  ##
## ------------ ##

# <2>(a*b*a*)
cat >a.gv <<\EOF
digraph
{
  vcsn_context = "lal_char(abc)_z"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
    F0
    F1
    F2
  }
  {
    node [shape = circle]
    0
    1
    2
  }
  I0 -> 0 [label = "<2>"]
  0 -> F0
  0 -> 0 [label = "a"]
  0 -> 1 [label = "b"]
  0 -> 2 [label = "a"]
  1 -> F1
  1 -> 1 [label = "b"]
  1 -> 2 [label = "a"]
  2 -> F2
  2 -> 2 [label = "a"]
}
EOF

# (<3>(ab))*
cat >b.gv <<\EOF
digraph
{
  vcsn_context = "lal_char(abc)_z"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
    F0
  }
  {
    node [shape = circle]
    0
    1
  }
  I0 -> 0 [label = "<3>"]
  0 -> F0
  0 -> 1 [label = "a"]
  1 -> 0 [label = "<3>b"]
}
EOF

cat >out.exp <<\EOF
digraph
{
  vcsn_context = "lal_char(abc)_z"
  rankdir = LR
  {
    node [style = invis, shape = none, label = "", width = 0, height = 0]
    I0
    F0
    F3
  }
  {
    node [shape = circle]
    0
    1
    2 [color = DimGray]
    3
  }
  I0 -> 0 [label = "<6>"]
  0 -> F0
  0 -> 1 [label = "a"]
  0 -> 2 [label = "a", color = DimGray]
  1 -> 3 [label = "<3>b"]
  3 -> F3
  3 -> 2 [label = "a", color = DimGray]
}
EOF

run 0 out.exp -vcsn product -f a.gv b.gv

## --------------------- ##
## Heterogeneous input.  ##
## --------------------- ##

# check OPERATION RES AUT...
# --------------------------
check()
{
  local op=$1; shift
  local expected=$1; shift
  local res="product($*)"
  run 0 ''          -vcsn "$op" -o "$res" -f "$@"
  run 0 "$expected" -vcsn aut-to-exp -f "$res"
}

# RatE and B, in both directions.
run 0 '' -vcsn standard -C 'lal_char(ab)_ratexpset<lal_char(uv)_b>' \
         -e '(<u>a+<v>b)*' -o ua+vb.gv
run 0 '' -vcsn standard -C 'lal_char(ab)_b' \
         -e 'a{+}' -o a+.gv
check product '<u>a+<u>a<u>a(<u>a)*' ua+vb.gv a+.gv
check product '<u>a+<u>a<u>a(<u>a)*' a+.gv ua+vb.gv

# Z, Q, R.
run 0 '' -vcsn derived-term -C 'lal_char(ab)_z' -o z.gv -e '(<2>a+<3>b)*'
run 0 '' -vcsn derived-term -C 'lal_char(ab)_q' -o q.gv -e '(<1/2>a+<1/3>b)*'
run 0 '' -vcsn derived-term -C 'lal_char(ab)_r' -o r.gv -e '(<.2>a+<.3>b)*'

check product '(a+b)*' z.gv q.gv
check product '(a+b)*' q.gv z.gv
check product '(<2>a+<3>b)*' z.gv q.gv z.gv
check product '(<1/2>a+<1/3>b)*' z.gv q.gv q.gv

check product '(<0.4>a+<0.9>b)*' z.gv r.gv
check product '(<0.4>a+<0.9>b)*' r.gv z.gv

check product '(<0.1>a+<0.1>b)*' q.gv r.gv
check product '(<0.1>a+<0.1>b)*' r.gv q.gv


## ----------------- ##
## Non-commutative.  ##
## ----------------- ##

run 0 '' -vcsn standard -C 'lal_char(ab)_ratexpset<lal_char(uv)_b>' \
         -e '<u>a<v>b' -o uavb.gv
run 0 '' -vcsn standard -C 'lal_char(ab)_ratexpset<lal_char(xy)_b>' \
         -e '<x>a<y>b' -o xayb.gv
run 0 '' -vcsn product -o uavb-xayb.gv -f uavb.gv xayb.gv
run 0 - -vcsn enumerate -f uavb-xayb.gv 4 <<\EOF
<uxvy>ab
EOF

## ------- ##
## n-ary.  ##
## ------- ##

for l in a b c d
do
  run 0 '' -vcsn standard -C 'lal_char(x)_ratexpset<lal_char(abcd)_b>' -e "<$l>x" -o $l.gv
done
run 0 '' -vcsn product -o abcd.gv -f a.gv b.gv c.gv d.gv
run 0 - -vcsn enumerate -f abcd.gv 10 <<\EOF
<abcd>x
EOF
