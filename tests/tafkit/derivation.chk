#! /bin/sh

##########################
## Regular derivation.  ##
##########################

# check RAT-EXP STRING RESULT
# ---------------------------
# Check that the derivation of RAT-EXP by STRING is RESULT.
check ()
{
  local re
  case $1 in
    ('(?@'*) re=$1;;
    (*)      re="(?@lal_char(abc)_ratexpset<lal_char(xyz)_z>)$1";;
  esac
  run 0 "$3" -vcsn derivation -Ee "$re" "$2"
}

## -------------------- ##
## Classical examples.  ##
## -------------------- ##

# EAT, Example 4.3.
E1='(<1/6>a*+<1/3>b*)*'
# E1 typed.
E1t="(?@lal_char(ab)_q)$E1"

## ------------------- ##
## derived_term(exp).  ##
## ------------------- ##

export VCSN_ORIGINS=1
run 0 -f $medir/e1-dt.gv -vcsn derived-term -Ee "$E1t"
unset VCSN_ORIGINS

# Make sure that "\e" is properly escaped.
export VCSN_ORIGINS=1
run 0 -f $medir/'a?-dt'.gv -vcsn derived-term -Ee "a?"
unset VCSN_ORIGINS

# check_intersection RE1 RE2...
# -----------------------------
# Check derived-term(intersection) = intersection(derived-term).
#
# Of course we'd like to use a "are-isomorphic", but we don't have one
# currently.  Meanwhile, check equality on the first accepted words,
# and one the info of both automata.
check_intersection ()
{
  # First, the derived-terms of each ratexp.
  local num=1
  # Number of letters to check in the output language.
  local length=4

  local auts
  for i
  do
    run 0 '' -vcsn derived-term -C "$ctx" -Ee "$i" -o $num.gv
    auts="$auts $num.gv"
    num=$((num + 1))
  done

  run 0 '' -vcsn product -o prod.gv -f $auts
  run 0 '' -vcsn cat -O info -o prod.info -f prod.gv
  run 0 '' -vcsn enumerate -o prod.list -f prod.gv $length

  # Check the derived-term of the intersection.
  local re
  for i
  do
    re="$re&($i)"
  done
  re=${re#&}
  run 0 '' -vcsn derived-term -C "$ctx" -Ee "$re" -o intersection.gv
  # Should be the same.
  run 0 -f prod.info -vcsn cat -O info -f intersection.gv
  run 0 -f prod.list -vcsn enumerate -f intersection.gv $length
}

ctx='lal_char(abc)_q'
check_intersection '(<1/6>a*+<1/3>b*)*' 'a*'
check_intersection '(<1/6>a*+<1/3>b*)*' 'b*'
check_intersection '(a+b+c)*a(a+b+c)*' '(a+b+c)*b(a+b+c)*' '(a+b+c)*c(a+b+c)*'

ctx='lal_char(abc)_ratexpset<lal_char(xyz)_b>'
check_intersection '(a+b+c)*<x>a(a+b+c)*' \
                   '(a+b+c)*<y>b(a+b+c)*' \
                   '(a+b+c)*<z>c(a+b+c)*'


###########################
## Breaking derivation.  ##
###########################


## -------------------------- ##
## breaking-derivation(exp).  ##
## -------------------------- ##

# check_br RAT-EXP STRING RESULT
# ------------------------------
# Check that the breaking derivation of RAT-EXP by STRING is RESULT.
check_br ()
{
  local re
  case $1 in
    ('(?@'*) re=$1;;
    (*)      re="(?@lal_char(abc)_ratexpset<lal_char(xyz)_z>)$1";;
  esac
  run 0 "$3" -vcsn derivation -Ee "$re" "$2" 1
}


## --------------------- ##
## Documented examples.  ##
## --------------------- ##

# On The Number Of Broken Derived Terms Of A Rational Expression.
F2='a*+b*'
E2="($F2)(a($F2))"
E2t="(?@lal_char(ab)_b)$E2"
check "$E2t" a "$F2 + a*a($F2)"
check "$E2t" b "b*a($F2)"

# Example 2.
check "$E2t" aa "a* + a*+b* + a*a($F2)"
check "$E2t" ab 'b*'
check "$E2t" ba "$F2"
check "$E2t" bb "b*a($F2)"

# Example 3.
export VCSN_ORIGINS=1
run 0 -f $medir/e2-dt.gv -vcsn derived-term -Ee "$E2t"
unset VCSN_ORIGINS

# Example 4.
run 0 "a*a($F2) + b*a($F2)" -vcsn split -Ee "$E2"
run 0 "a* + b*" -vcsn split -Ee "$F2"

# Example 5.
check_br "$E2t"  a "a* + b* + a*a($F2)"
check_br "$E2t"  b "b*a($F2)"
check_br "$E2t" aa "a* + b* + a*a($F2)"
check_br "$E2t" ab 'b*'
check_br "$E2t" ba "a* + b*"
check_br "$E2t" bb "b*a($F2)"
export VCSN_ORIGINS=1
run 0 -f $medir/e2-dt-breaking.gv -vcsn derived-term -Ee "$E2t" 1
unset VCSN_ORIGINS

# Figure 3.
export VCSN_ORIGINS=1
run 0 -f $medir/h3-dt.gv -vcsn derived-term -Ee 'a(b+c+d)'
run 0 -f $medir/h3-dt-breaking.gv -vcsn derived-term -Ee 'a(b+c+d)' 1
unset VCSN_ORIGINS
