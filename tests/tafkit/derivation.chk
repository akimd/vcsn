#! /bin/sh

##########################
## Regular derivation.  ##
##########################

## ----------------- ##
## derivation(exp).  ##
## ----------------- ##

# check RAT-EXP STRING RESULT
# ---------------------------
# Check that the derivation of RAT-EXP by STRING is RESULT.
check ()
{
  local re
  case $1 in
    ('(?@'*) re=$1;;
    (*)      re="(?@lal_char(abc)_ratexpset<lal_char(xyz)_z>)$1";;
  esac
  run 0 "$3" -vcsn derivation -e "$re" "$2"
}

## ---------------------------- ##
## Derive wrt a single letter.  ##
## ---------------------------- ##

# Zero, one.
check    '\z' a '\z'
check    '\e' a '\z'
check '<x>\e' a '\z'

# Letters.
check    'a' a '\e'
check    'a' b '\z'
check '<x>a' a '<x>\e'
check '<x>a' b '\z'

# Sum.
check '<x>a+<y>b' a '<x>\e'
check '<x>a+<y>b' b '<y>\e'
check '<x>a+<y>a' a '<x+y>\e'

# Prod.
check 'ab' 'a' 'b'
check 'ab' 'b' '\z'
check '(<x>a).(<y>a).(<z>a)' 'a' '<x><y>a.<z>a'

# Intersection.
check '<x>a&<y>a&<z>a' a '<x.y.z>\e'
check '<x>a&<y>a&<z>a' b '\z'

check '(<x>a+<y>b)*&(<z>b+<x>c)*' a '\z'
check '(<x>a+<y>b)*&(<z>b+<x>c)*' b '<y.z>(<x>a+<y>b)*&(<z>b+<x>c)*'
check '(<x>a+<y>b)*&(<z>b+<x>c)*' c '\z'

# Star.
check 'a*' a 'a*'
check 'a*' b '\z'
check '(<x>a)*' a '<x>(<x>a)*'
check '(<x>a)*' b '\z'
check '<x>a*'   a '<x>a*'
check '<x>(<y>a)*' a '<x.y>(<y>a)*'


## ------------------------------- ##
## Derive wrt to several letters.  ##
## ------------------------------- ##

check '(<x>a)*' aa   '<x.x>(<x>a)*'
check '(<x>a)*' aaaa '<x.x.x.x>(<x>a)*'
check '(<x>a)*' aaab '\z'

check '(<x>a)*(<y>b)*' aa   '<x.x>(<x>a)*.(<y>b)*'
check '(<x>a)*(<y>b)*' aabb '<x.x.y.y>(<y>b)*'


## -------------------- ##
## Classical examples.  ##
## -------------------- ##

# EAT, Example 4.3.
E1='(<1/6>a*+<1/3>b*)*'
# E1 typed.
E1t="(?@lal_char(ab)_q)$E1"
check "$E1t"  a  "<1/3>a*.$E1"
check "$E1t"  b  "<2/3>b*.$E1"
check "$E1t" aa  "<4/9>a*.$E1"
check "$E1t" ab  "<2/9>b*.$E1"
check "$E1t" ba  "<2/9>a*.$E1"
check "$E1t" bb "<10/9>b*.$E1"


## ------------------- ##
## derived_term(exp).  ##
## ------------------- ##

export VCSN_ORIGINS=1
run 0 -f $medir/e1-dt.gv -vcsn derived-term -e "$E1t"
unset VCSN_ORIGINS

# Make sure that "\e" is properly escaped.
export VCSN_ORIGINS=1
run 0 -f $medir/'a?-dt'.gv -vcsn derived-term -e "a?"
unset VCSN_ORIGINS

# check_intersection RE1 RE2...
# -----------------------------
# Check derived-term(intersection) = intersection(derived-term).
#
# Of course we'd like to use a "are-isomorphic", but we don't have one
# currently.  Meanwhile, check equality on the first accepted words,
# and one the info of both automata.
check_intersection ()
{
  # First, the derived-terms of each ratexp.
  local num=1
  # Number of letters to check in the output language.
  local length=4

  local auts
  for i
  do
    run 0 '' -vcsn derived-term -C "$ctx" -e "$i" -o $num.gv
    auts="$auts $num.gv"
    num=$((num + 1))
  done

  run 0 '' -vcsn product -o prod.gv -f $auts
  run 0 '' -vcsn cat -O info -o prod.info -f prod.gv
  run 0 '' -vcsn enumerate -o prod.list -f prod.gv $length

  # Check the derived-term of the intersection.
  local re
  for i
  do
    re="$re&($i)"
  done
  re=${re#&}
  run 0 '' -vcsn derived-term -C "$ctx" -e "$re" -o intersection.gv
  # Should be the same.
  run 0 -f prod.info -vcsn cat -O info -f intersection.gv
  run 0 -f prod.list -vcsn enumerate -f intersection.gv $length
}

ctx='lal_char(abc)_q'
check_intersection '(<1/6>a*+<1/3>b*)*' 'a*'
check_intersection '(<1/6>a*+<1/3>b*)*' 'b*'
check_intersection '(a+b+c)*a(a+b+c)*' '(a+b+c)*b(a+b+c)*' '(a+b+c)*c(a+b+c)*'

ctx='lal_char(abc)_ratexpset<lal_char(xyz)_b>'
check_intersection '(a+b+c)*<x>a(a+b+c)*' \
                   '(a+b+c)*<y>b(a+b+c)*' \
                   '(a+b+c)*<z>c(a+b+c)*'


###########################
## Breaking derivation.  ##
###########################


## -------------------------- ##
## breaking-derivation(exp).  ##
## -------------------------- ##

# check_br RAT-EXP STRING RESULT
# ------------------------------
# Check that the breaking derivation of RAT-EXP by STRING is RESULT.
check_br ()
{
  local re
  case $1 in
    ('(?@'*) re=$1;;
    (*)      re="(?@lal_char(abc)_ratexpset<lal_char(xyz)_z>)$1";;
  esac
  export VCSN_BREAKING=1
  run 0 "$3" -vcsn derivation -e "$re" "$2"
  unset VCSN_BREAKING
}

## ---------------------------- ##
## Derive wrt a single letter.  ##
## ---------------------------- ##

# Zero, one.
check_br    '\z' a '\z'
check_br    '\e' a '\z'
check_br '<x>\e' a '\z'

# Letters.
check_br    'a' a '\e'
check_br    'a' b '\z'
check_br '<x>a' a '<x>\e'
check_br '<x>a' b '\z'

# Sum.
check_br '<x>a+<y>b' a '<x>\e'
check_br '<x>a+<y>b' b '<y>\e'
check_br '<x>a+<y>a' a '<x+y>\e'

# Prod.
check_br 'ab' 'a' 'b'
check_br 'ab' 'b' '\z'
check_br '(<x>a).(<y>a).(<z>a)' 'a' '<x.y>a.<z>a'

# Star.
check_br 'a*' a 'a*'
check_br 'a*' b '\z'
check_br '(<x>a)*' a '<x>(<x>a)*'
check_br '(<x>a)*' b '\z'
check_br '<x>a*'   a '<x>a*'
check_br '<x>(<y>a)*' a '<x.y>(<y>a)*'

## --------------------- ##
## Documented examples.  ##
## --------------------- ##

# On The Number Of Broken Derived Terms Of A Rational Expression.
F2='a*+b*'
E2="($F2)(a($F2))"
E2t="(?@lal_char(ab)_b)$E2"
check "$E2t" a "$F2 + a*.a.($F2)"
check "$E2t" b "b*.a.($F2)"

# Example 2.
check "$E2t" aa "a* + a*+b* + a*.a.($F2)"
check "$E2t" ab 'b*'
check "$E2t" ba "$F2"
check "$E2t" bb "b*.a.($F2)"

# Example 3.
export VCSN_ORIGINS=1
run 0 -f $medir/e2-dt.gv -vcsn derived-term -e "$E2t"
unset VCSN_ORIGINS

# Example 4.
run 0 "a*.a.($F2) + b*.a.($F2)" -vcsn split -e "$E2"
run 0 "a* + b*" -vcsn split -e "$F2"

# Example 5.
check_br "$E2t"  a "a* + b* + a*.a.($F2)"
check_br "$E2t"  b "b*.a.($F2)"
check_br "$E2t" aa "a* + b* + a*.a.($F2)"
check_br "$E2t" ab 'b*'
check_br "$E2t" ba "a* + b*"
check_br "$E2t" bb "b*.a.($F2)"
export VCSN_BREAKING=1 VCSN_ORIGINS=1
run 0 -f $medir/e2-dt-breaking.gv -vcsn derived-term -e "$E2t"
unset VCSN_BREAKING VCSN_ORIGINS

# Figure 3.
export VCSN_ORIGINS=1
run 0 -f $medir/h3-dt.gv -vcsn derived-term -e 'a(b+c+d)'
export VCSN_BREAKING=1
run 0 -f $medir/h3-dt-breaking.gv -vcsn derived-term -e 'a(b+c+d)'
unset VCSN_BREAKING
unset VCSN_ORIGINS
