import re
import subprocess
import sys

from queue import Empty

from difflib import ndiff as diff
from jupyter_client import KernelManager
from nbformat import v4 as formatter

def truncate(text):
    '''Truncate a too long text to its first characters.'''
    text = str(text)
    # Dicts: keep curly brackets, truncate inside.
    text = re.sub(r'\{(.{60}).*\}', r'{\1...}', text)
    # Lists: same with square brackets.
    text = re.sub(r'\[(.{60}).*\]', r'[\1...]', text)
    # Other types: truncate as well.
    text = re.sub(r'(?s)^([^\{\[].{60}).*', r'\1...', text)
    # Keep it one line.
    text = text.replace('\n', '\\n')
    return text

def repr_list(l):
    '''Stringify a list of dicts by only showing the keys, in order.

    This is only called when an output list length mismatch occurs, to give the
    user just enough information on what the different output is.'''
    res = '['
    for d in l:
        res += re.sub(r'\[(.*)\]', r'{\1}', str(sorted(list(d.keys()))))
        res += ', '
    res = res.rstrip(', ')
    res += ']'
    return res

def flatten(d):
    '''Turn nested dicts into a single dict
    to avoid recursion in `compare_outputs`.'''
    flat = []
    for key, value in d.items():
        if isinstance(value, dict):
            flat.extend(flatten(value).items())
        else:
            flat.append((key, value))
    return dict(flat)

def canonicalize(s):
    """canonicalize a string for comparison.

    fix universal newlines, strip trailing newlines, and normalize likely
    random values (memory addresses and UUIDs)
    """
    s = str(s)
    # normalize newline:
    s = s.replace('\r\n', '\n')

    # ignore trailing newlines (but not space)
    s = s.rstrip('\n')

    # remove hex addresses:
    s = re.sub(r'at 0x[a-f0-9]+', 'object', s)

    # normalize UUIDs:
    s = re.sub(r'[a-f0-9]{8}(\-[a-f0-9]{4}){3}\-[a-f0-9]{12}', 'U-U-I-D', s)

    # normalize graphviz version
    s = re.sub(r'(Generated by graphviz version ).*', r'\1VERSION', s)

    # SVG generated by graphviz may put note at different positions
    # depending on the graphviz build.  Let's just strip anything that
    # looks like a position or size.
    s = re.sub(r'<path[^/]* d="[^"]*"', '<path', s)
    s = re.sub(r'points="[^"]*"', 'points=""', s)
    s = re.sub(r'x="[0-9.-]+"', 'x=""', s)
    s = re.sub(r'y="[0-9.-]+"', 'y=""', s)
    s = re.sub(r'width="[0-9.]+pt"', 'width=""', s)
    s = re.sub(r'height="[0-9.]+pt"', 'height=""', s)
    s = re.sub(r'viewBox="[0-9 .-]*"', 'viewbox=""', s)
    s = re.sub(r'transform="[^"]*"', 'transform=""', s)
    s = re.sub(r'font-size="[^"]*"', 'font-size=""', s)

    # normalize wether data was already there or not
    s = re.sub(r'(Over)?[Ww]rit', 'Writ', s)

    # normalize paths
    s = re.sub('/([^/]+/){2,}', '', s)
    return s

def compare_outputs(test, ref):
    ref = flatten(ref)
    test = flatten(test)
    kref = sorted(list(ref.keys()))
    ktest = sorted(list(test.keys()))
    if kref != ktest:
        print("keys differ:")
        print("    Expected: ", kref)
        print("    Effective:", ktest)
        return False
    for key in kref:
        exp = canonicalize(ref[key])
        eff = canonicalize(test[key])
        if exp != eff:
            for k in kref:
                print("  REF:", k, truncate(ref[k]))
                print("  TST:", k, truncate(test[k]))
            print("mismatch %s:" % key)
            print('\n'.join(diff(exp.splitlines(), eff.splitlines())))
            return False
    return True

def run_cell(kc, cell):
    kc.execute(cell['source'])
    # This is useful but will make the notebook crash on long executions, such as
    # when the cache is empty, which can cause problems when doing bulk testing.
    # kc.get_shell_msg(timeout=20)
    kc.get_shell_msg()
    outs = []
    while True:
        msg = kc.get_iopub_msg(timeout=0.2)
        msg_type = msg['msg_type']
        content = msg['content']
        if msg_type == 'status' and content['execution_state'] == 'idle':
            break
        if msg_type in ('status', 'pyin', 'execute_input',
                        'comm_open', 'comm_msg'):
            continue
        # Use stream and should be kept:
        #   print, %%file, !
        # Use stream and should be ignored:
        #   widgets that crashes
        if msg_type == 'stream':
            if 'Widget' in content['text']:
                continue
            # If the last stream had the same name,
            # then outputs are appended.
            if len(outs):
                last = outs[-1]
                if last['output_type'] == 'stream' and \
                   last['name'] == content['name']:
                    last['text'] += content['text']
                    continue
        if msg_type == 'clear_output':
            outs = []
            continue
        content['output_type'] = msg_type
        outs.append(content)
    return outs

def test_notebook(ipynb):
    print('\nTesting notebook {}'.format(ipynb))
    with open(ipynb) as f:
        nb = formatter.reads_json(f.read())
    km = KernelManager()
    # Do not save the history to disk, as it can yield spurious lock errors.
    # See https://github.com/ipython/ipython/issues/2845
    km.start_kernel(extra_arguments=['--HistoryManager.hist_file=:memory:'],
                    stderr=subprocess.DEVNULL)
    kc = km.client()
    kc.start_channels()
    kc.wait_for_ready()
    npass, nfail, nerror = 0, 0, 0
    for n, cell in enumerate(nb['cells']):
        if cell['cell_type'] != 'code':
            continue
        # `%timeit`s shall count in execution count
        if cell['source'].startswith('%timeit'):
            run_cell(kc, {'source': 'pass'})
            continue
        i = cell['execution_count']
        try:
            outs = run_cell(kc, cell)
        except Empty:
            print('Failed to run cell #{} ({}):'.format(i, n),
                  '    Kernel Client is Empty; this is most likely due to a',
                  '    timeout issue. Check with `vcsn ps` or run the notebook',
                  '    manually, then retry.', file=sys.stderr, sep='\n')
            print('Source was:\n', cell['source'])
            nerror += 1
            continue
        except Exception as e:
            print('Failed to run cell #{} ({}):'.format(i, n), repr(e),
                  file=sys.stderr)
            print('Source was:', cell['source'], sep='\n')
            nerror += 1
            continue
        failed = False
        if len(outs) != len(cell['outputs']):
            print("output length mismatch (expected {}, got {})".format(
                  len(cell['outputs']), len(outs)))
            print('    Expected: ', truncate(repr_list(cell['outputs'])))
            print('    Effective:', truncate(repr_list(outs)))
            failed = True
        for out, ref in zip(outs, cell.outputs):
            failed |= not compare_outputs(out, ref)
        print('cell #{}'.format(i), end='')
        if failed:
            print(' ({}): FAIL'.format(n))
            nfail += 1
        else:
            print(': OK')
            npass += 1
    print("Tested notebook {}".format(ipynb))
    print("    {:3} cells successfully replicated".format(npass))
    if nfail:
        print("    {:3} cells mismatched output".format(nfail))
    if nerror:
        print("    {:3} cells failed to complete".format(nerror))
    kc.stop_channels()
    km.shutdown_kernel()
    del km
    return False if nfail or nerror else True

if __name__ == '__main__':
    success = True
    for ipynb in sys.argv[1:]:
        success &= test_notebook(ipynb)
    sys.exit(0 if success else 1)
