#! /bin/sh

set -e

me=`basename $1 .chk`

# Number of the current test.
number=1

# Exit status of this script.
exit=true

# Make them absolute.
builddir=$(pwd)
srcdir=$(cd $srcdir && pwd)
test=$(cd $(dirname $1) && pwd)/$(basename $1)


# stderr LINES
# ------------
stderr ()
{
  local i
  for i
  do
    echo "$i"
  done | sed -e "s/^/$me: /" >&2
}


# error EXIT MESSAGES
# -------------------
error ()
{
  local exit="$1"
  shift
  stderr "$@"
  exit $exit
}


# fatal MESSAGES
# --------------
fatal ()
{
  error 1 "$@"
}


# rst_title TITLE
# ---------------
rst_title ()
{
  echo "$@" | sed 's/.*/   &   /;h;s/./=/g;p;x;p;g;p;s/.*//'
}

# rst_section_ LINER TITLE
# ------------------------
rst_section_ ()
{
  local liner="$1"
  shift
  echo "$@" | sed "p;s/./$liner/g;p;g"
  echo
}

# rst_section TITLE
# -----------------
rst_section ()
{
  rst_section_ "=" "$@"
}

# rst_subsection TITLE
# --------------------
rst_subsection ()
{
  rst_section_ "-" "$@"
}

# rst_subsubsection TITLE
# -----------------------
rst_subsubsection ()
{
  rst_section_ "." "$@"
}

# rst_tab [FILES = stdin]
# -----------------------
rst_tab ()
{
  # We use "cat -v" so that we don't miss hidden characters, but
  # also so Windows runs don't display with an empty line between
  # one line.  They now display as "LINE^M".
  cat -v "$@" | perl -pe 's/\^\[\[33/\x1B\[33/g;s/^/\t/'
  echo
}

# rst_pre TITLE [FILE]
# --------------------
# FILE may be empty to denote stdin.
rst_pre ()
{
  if test $# -eq 1 || test -s "$2"; then
    echo "$1::"
    echo
    shift
    rst_tab "$@"
  fi
}


# rst_expect BASE [DIFF-FLAGS]
# ----------------------------
# Compare expected output with effective, actual, output.
# Set $exit to false if there is a failure.
rst_expect ()
{
  local base=$1
  shift
  # Whether this test passed.
  local res=0

  test -f $base.exp ||
    fatal "missing reference file: $base.exp"

  rst_subsubsection "$me: $base"
  # Dump something, it is really surprising in the logs to see
  # nothing.
  rst_pre "Expected $base for $me" $base.exp
  # --strip-trailing-cr helps to fight \r.
  if ! diff --strip-trailing-cr -u                              \
            --label="Expected $base ($base.exp)"  $base.exp     \
            --label="Effective $base ($base.eff)" $base.eff     \
            "$@"                                                \
            >$base.diff; then
    res=1
    rst_pre "Effective $base for $me"   $base.eff
    rst_pre "Diffs on $base for $me"    $base.diff
    # If exit is already set, e.g. to "exit SKIP", don't alter it.
    case $exit in
      ('' | true) exit=false;;
    esac
  fi
  return $res
}


# run EXPECTED-EXIT-STATUS EXPECTED-OUTPUT PROG [PROG-OPTIONS]
# ------------------------------------------------------------
# If "EXPECTED-OUTPUT" is "out.exp", then use the content of that file
# as expected output, otherwise EXPECTED-OUTPUT is the expected
# output.
run ()
{
  # Expected exit status.
  local sta_exp=$1
  shift
  # Expected output.
  local out_exp=$1
  shift
  if test "$out_exp" != out.exp; then
    cat >out.exp <<EOF
$out_exp
EOF
  fi
  # program to run
  local prog=$1
  shift

  # First, run the test, so that the title can include the status of
  # the run.
  local fail=
  # Effective exit status, output and error.
  local sta_eff=0
  # Be robust to set -e.
  $builddir/$prog "$@" >out.eff 2>err.eff || sta_eff=$?
  if test $sta_eff -ne $sta_exp; then
    echo "$me: FAIL: $number (expected status: $sta_exp, effective: $sta_eff)"
    exit=false
    fail="FAIL: "
  fi
  {
      rst_expect out || fail="FAIL: "
      rst_pre "Standard error" err.eff || fail="FAIL: "
  } >stdout.tmp
  rst_subsection "${fail}Test $number: $@"
  cat stdout.tmp - <<EOF

command
  $prog $@

status
  $sta_eff

EOF


  number=`expr $number + 1`
}


# cleanup
# -------
# Remove the temp dir and exit, preserving the exit status.
cleanup ()
{
  local status=$?
  if test -z "$DEBUG"; then
     cd $builddir
     rm -rf $me.dir
  fi
  exit $status
}
trap cleanup 0 1 2 13 15
rm -rf $me.dir
mkdir $me.dir
cd $me.dir

. "$test"

$exit
