#! /usr/bin/perl

use File::Basename;

my $black = `tput setaf 0`;
my $blue = `tput setaf 4`;
my $cyan = `tput setaf 6`;
my $green = `tput setaf 2`;
my $red = `tput setaf 1`;
my $white = `tput setaf 7`;
my $std = `tput init`;

my $FAIL = "${red}FAIL$std";
my $PASS = "${green}PASS$std";

my $fail = 0;

sub quote ($)
{
  my ($in) = @_;
  $in =~ s/(["$\\`])/\\$1/g;
  $in =~ s/^[ \t]*//g;
  $in =~ s/[ \t]*$//g;
  $in;
}

=item C<pp($prog, $in)>

Parse and pretty-print.  If it fails, prepend "! " to the error
message and return it as result.

=cut
sub pp ($$)
{
  my ($prog, $in) = @_;
  $in = quote($in);
  my $res = `$prog -e '$in' 2>&1`;
  $res = "! $res"
    if $?;
  chomp($res);
  $res;
}

sub check_rat_exp($$)
{
  my ($prog, $file) = @_;

  use IO::File;
  my $in = new IO::File($file)
    or die "$file: cannot open: $!\n";
  while ($_ = $in->getline())
    {
      my $line = $in->input_line_number;
      chomp;
      s/\s*#.*//;
      next
        unless $_;

      if (/%weight: (.*)/)
        {
          $ws = $1;
          my $title = "WeightSet: $ws";
          print "$title\n";
          $title =~ s/./-/g;
          print "$title\n";
          next;
        }

      if (/%include: (.*)/)
        {
          my $f = dirname($file) . "/" . $1;
          check_rat_exp($prog, $f);
          next;
        }

      m/^(.*\S)\s*(=>|==|!)\s*(.*)$/
        or die "$file:$line: invalid input: \"$_\"";
      my ($l, $op, $r) = ($1, $2, $3);
      my $L = pp("$prog -w $ws", $l);

=item C<fail($expression, $expected, $effective)>

Register the failure of the evaluation of C<$expression>: instead of
C<$expected>, it evaluated to C<$effective>.

=cut
      sub fail($$$)
      {
        my ($expr, $expt, $eff) = @_;
        ++$fail;
        print "- $file:$line: $FAIL: $expr\n";
        print "\n";
        print "  - exp: $expt\n";
        print "  - eff: $eff\n";
        print "\n";
      }

      # == tests that boths are equivalent.
      # => check the actual result.
      # !  error, with the given error message.
      my $R =
        ($op eq '=>'   ? quote($r)
         : $op eq '==' ? pp("$prog -w $ws", $r)
         : "! $r"); # $op eq '!',
      # Empty result is a sign of failure.
      if ($L ne '' && $L eq $R)
      {
        print "- $PASS: $l $op $r";
        print " (=> $L)" if $L ne $r;
        print "\n";
      }
      else
      {
        fail("$l $op $r", $R, $L);
      }
    }
}

my $prog = shift @ARGV;
check_rat_exp($prog, $_)
  foreach @ARGV;

exit !!$fail;


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
