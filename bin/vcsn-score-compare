#! /usr/bin/env python

from __future__ import print_function
import os, re, sys
import argparse

parser = argparse.ArgumentParser(description='Bench some algorithms.')
parser.add_argument('files', metavar='files', nargs='+',
                    type=str, default=None,
                    help='Bench files (from vcsn score) to compare')
parser.add_argument('--only', metavar='RE',
                    type=re.compile, default='.*',
                    help='Report only benches whose title is matched by RE')
parser.add_argument('--treshold', metavar='treshold',
                    type=float, default=0.1,
                    help='show good and bad scores with associated treshold')
args = parser.parse_args()

bench = dict()

def normalize(k):
    '''Fix a bench fix, i.e., fix errors, update APIs etc.
    '''

    # Separate with " # " only.
    k = " # ".join(map(str.strip, k.split('#', 2)))

    # The right symbol for repeated &.
    k = re.sub(r'a\*\*(\d+) ', r'a & \1', k)
    # Fix: spello.
    k = re.sub(r'de_buijn', 'de_bruijn', k)
    # Fix: extraneous paren.
    k = re.sub(r'ladybird\(21\)\)', 'ladybird(21)', k)
    # Fix: Incorrect use of .format.
    k = re.sub(r'(a.(?:product|shuffle)\(a\) # a = std\(\{\}\).format\(r\))',
               lambda m: m.group(1).replace('{}', '[a-e]?{50})'),
               k)
    # Fix: now use 's' to denote a string, instead of 'a'.
    k = re.sub(r'read\(a\) # a =',
               r'read(s) # s =', k)
    # Now we display the number of repetitions.
    k = re.sub(r'(# a = de_bruijn\(150\))$', r'\1, 1000x', k)
    k = re.sub(r'(# e = "\(\\e\+a\)" \* 500)$', r'\1, 100x', k)
    k = re.sub(r'(# r = b\.expression\("\(\\e\+a\)" \* 500\))$', r'\1, 1000x', k)
    # Now, instead of "   on [a-z]  -> Z", ", c = [a-z] -> Z".
    k = re.sub(r' +on (\[.*?\][?*]?) *-> *([BQZ])',
               r', c = \1 -> \2', k)
    k = re.sub(r'a = lal\(a-zA-Z0-9\).ladybird\(18\)',
               r'a = ladybird(18), c = [a-zA-Z0-9] -> B', k)
    # We never worked on Q in score, it was a typo.  And working with
    # B is good enough anyway and more relevant.
    k = re.sub(r'(determinize.*de_bruijn\(\d+\)), c = \[abc\] -> [BQ]',
               r'\1', k)

    # derived_term.
    k = k.replace("derived_term()", 'derived_term("derivation")')
    k = k.replace("linear()", 'derived_term("expansion")')

    # For a while we displayed "a.sort() # a = std([a-e]?{600})" but
    # were actually running "a.shortest(5)".
    k = re.sub(r'a.sort\(\) (# a = std\(\[a-e\]\?\{600\}\))',
               r'a.shortest(5) \1', k)

    # The syntax of contexts has changed.
    k = re.sub(r'lal_char\(abc\)(_|, )b', '[abc] -> B', k)

    k = k.replace('ratexp', 'expression')

    k = k.replace('a.num_sccs', 'a.scc')

    k = k.replace('a.accessible ', 'a.accessible() ')

    k = "{:20s} # {}".format(*map(str.strip, k.split('#', 2)))
    return k

def read(fn):
    with open(fn) as f:
        for line in f:
            v, k = map(str.strip, line.split(':', 1))
            # Get rid of "s", we know the unit.
            v = v[:-1]
            # Fix errors in algo descriptions.
            k = normalize(k)
            if k not in bench:
                bench[k] = dict()
            bench[k][fn] = v

# Read the score files.
for fn in args.files:
    read(fn)

# SET COLORS FOR TERM
BLACK, RED, GREEN, WHITE = range(4)
def has_colours(stream):
    if not hasattr(stream, "isatty"):
        return False
    if not stream.isatty():
        return False # auto color only on TTYs
    try:
        import curses
        curses.setupterm()
        return curses.tigetnum("colors") > 2
    except:
        return False
has_colours = has_colours(sys.stdout)
# print method with associated color
def printout(text, colour=WHITE):
        if has_colours:
                seq = "\x1b[1;%dm" % (30+colour) + text + "\x1b[0m"
                sys.stdout.write(seq)
        else:
                sys.stdout.write(text)

# Print the score table.
for k in sorted(bench.keys()):
    if args.only.search(k):
        for fn in args.files:
            # Compute average of benchs.
            bs = [float(bench[k][f]) for f in args.files if f in bench[k]]
            avg = sum(bs) / len(bs)
            # print with right colors.
            v = bench[k][fn] if fn in bench[k] else "N/A"
            if fn in bench[k]:
                if float(bench[k][fn]) <= avg - args.treshold * avg:
                    printout("{:5}".format(v), GREEN)
                    print(end = ' ')
                elif float(bench[k][fn]) >= args.treshold * avg + avg:
                    printout("{:5}".format(v), RED)
                    print(end = ' ')
                else:
                    print("{:5}".format(v), end= ' ')
            else:
                    print("{:5}".format(v), end= ' ')
        print(k)
