* Bugs
** is-deterministic (see tafkit/is-deterministic-fail.chk).
It fails to check properly that the input automaton is-realtime.  But
is this a task for vcsn::is-deterministic, for dyn::is-deterministic,
or vcsn-is-deterministic?  More generally, should all three layers
have the same specifications?  I vote yes, but efficiency might
dictate a different choice.

** edit-automaton
Finish cleaning: we must stop reading as word_t, and use only label_t.
See the item below.

** dot parser (see FIXME in tafkit/cat.chk)
We accept invalid labels:

  digraph
  {
    vcsn_context = "lal_char(a)_b"
    1 -> 2 [label = "aa"]         // invalid LAL
    2 -> F2
    I1 -> 1
  }

  digraph
  {
    vcsn_context = "lal_char(a)_b"
    1 -> 2 [label = "\e"]        // invalid LAL
    2 -> F2
    I1 -> 1
  }

both are related to our use of entries to parse labels: entries are
about *words*, while we want them to be about *labels*.  So we are
missing control in lal (and lan):

    template <typename Ctx>
    void
    add_entry_(state_t src, state_t dst,
               if_lal<Ctx, const entry_t&> es)
    {
      for (auto e: es)
        // FIXME: Hack.  entries are always about words, but we
        // want letters.  "e.first[0]" is a hack for lal.
        add_transition(src, dst, e.first[0], e.second);
    }

we don't check that there is a single letter in the label here, nor
that it is not the \e.  Rather than a quick fix, we need to really
talk about the nature of entries.

** Generators and alphabets
ladybird "works" properly on "lal_char(ab)_b", although it needs abc.
Of course, output then fails.  Should ladybird enrich the alphabet?
Or use what's in there instead of always abc?

** dyn::weight
Would that be useful?  For the return value of eval for instance.  How
would the connection with dyn::ratexp (which are weights) be done?

* Benchmarks
** determinization
Experiment determinization on (a^p)*+(a^q)*+(a^r)*, with p, q, r primes.
Possible name: "Chrobak" (reference to Marek Chrobak), "cycles", "gears".

** determinization
Introduce aaaaa+aaaab+...+bbbbb for length n.

** eps-removal
(1+a)^n

* aut-to-exp
** More heuristics
See what V1 did.

** Incremental
Transform the current implementation of the "naive" heuristics into
some incremental.  See what TAF-Kit.pdf B.1.4.1 says about it.

* eval.chk
Cover more cases for zmin.

* trivial identities
As a goal, we want every rational expression to yield the same result
in lal and law.  This is a failure:

  $ vcsn-cat -C 'lal_char_z' -e 'ab{3}' -E
  (a.b){3}
  $ vcsn-cat -C 'law_char_z' -e 'ab{3}' -E
  {3}ab

Note that TAF-Kit's documentation (Section 2.2.1) precisely reports
that *both* should yield "{3}ab":

  Caveat: The definition of the identity Cat corresponds to what is
  actually implemented in Vaucanson 1.4 and is somehow a mistake. A more
  natural definition would be m{k} â‡’ {k}m with m any element of the
  monoid. This may be corrected in forthcoming revisions of Vaucanson
  1.4 but should anyway be reevaluated in connection with the definition
  of the function derived-term for the weighthed automata.

* "check" algorithm
There should be a means to check that the invariants are verified.  A
separate algorithm would do.  In particular check the alphabet, that
the special letter labels the initial and final transitions etc.

* edit-automaton
Currently it converts the \e in initial/final labels to the
special-letter.  Is this what we want?
Shouldn't we replace assert() with if (...) throw ... ?

* debug compilation mode
crange should not feature size and empty if !VCSN_DEBUG.

* vcsn/alphabets/char.cc
  char_letters::special_letter(...) is protected and
  set_alpha<T>::add_letter(...) (in file vcsn/alphabets/setalpha.hh)
  need it.

* mutable_automaton::set_transition
We should find a means to forbid transition from pre to post.  This
was the case initially, but it is a useless constraint in aut-to-exp.
Maybe it should be efforced only in non labels_are_unit case.

* automata: handle with shared_ptr
One would really like to have a transpose_automaton that is able to
build its underlying automaton.  This means that using a const& to
keep the original automaton is not the best model: pointers would be
better.  But then there are issues with memory tracking, issues that
we already know how to handle thanks to shared_ptr.

* compilation jit
Well, you know what I mean.

* char.hh:
choose bw "word_t w", and const&.

* move files around
The hierarchy and the namespaces do not match.

* have a consuming version of conv()
The conversion function of weights currently takes a string and returns
a weight.  It would be convenient to have a conversion that is equivalent
to the >> operator: i.e., it reads the leading weight, and return the rest.
(Should we use a stream-based interface or an iterator-based interface?)
Similar conversion functions should be made available for labels.

This is especially important when parsing weights with a recursive
structure (e.g., polynomials or rational expressions).  For instance
in

              while (labelset()->has(i.peek()))
                label += char(i.get());

polynomialset::conv() wrongly assumes that letters are represented by
characters.  This will break with integer alphabets.

* should polynomial honor the kind?
Currently polynomials maps words to weights.  However when polynomial
are used to represent entries of a LAL automaton, it would make sense
to map only letters to weights.  Can this be useful elsewhere?

Local Variables:
mode: outline
End:
