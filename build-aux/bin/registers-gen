#! /usr/bin/env python

# This tool reads the algorithms header files looking for entries as
# follows:
#
#   /// Bridge (trie).
#   template <typename Context, typename Istream>
#   automaton
#   trie_stream(const context& ctx, std::istream& is)
#   {
#     const auto& c = ctx->as<Context>();
#     auto ps = make_word_polynomialset(c);
#     return make_automaton(trie(ps, is));
#   }
#
# it does not care about the part in braces: only the comment and the
# signature are read.
#
# Be sure to respect the comment:
#
#   /// Bridge (<ALGO>).
# or
#   /// Bridge.
#
# in the common case where the register name is the same as the
# function name, as exposed in dyn:: to the user.
import argparse
import os
import re

# A dictionary of all the bridges, with the register name as key.
# Bridges are dictionaries providing the following keys:
#
# args: the effective arguments (e.g., "aut, i").
# call: 'call' or 'call_variadic'.
# file: the vcsn/algos header that provides the bridge.
# formals: the formals arguments (e.g., "const automaton& aut, unsigned i").
# algo: function name (e.g., multiply).
# reg: register name (e.g., multiply_polynomial).
# return: return type.
bridges = {}

bridge_pattern = re.compile(r'''///\ Bridge(?:\s+\((?P<algo>\w+)\))?.
\s*template\s*<.*?>
(?:\s*inline)?
\s*(?P<return>[\w:&*]+)\s+(?P<reg>\w+)\s*\((?P<formals>.*?)\)''',
                    flags=re.VERBOSE | re.DOTALL)

register = '''  // {reg} ({file}).
  REGISTER_DECLARE({reg},
    ({formals}) -> {return});

'''

implementation = '''
  // {reg} ({file}).
  REGISTER_DEFINE({reg});
  {return}
  {algo}({formals})
  {{
    return detail::{reg}_registry().{call}({args});
  }}

'''

def process_file(fn):
    '''Store in bridges the signatures from header fn.'''
    with open(fn, 'r') as f:
        for m in bridge_pattern.finditer(f.read()):
            bridge = m.groupdict()
            bridge['file'] = os.path.basename(fn)
            reg = bridge['reg']
            # Compute the algo name.
            if bridge['algo'] == None:
                bridge['algo'] = reg
            bridge['formals'] = re.sub('\s+', ' ', bridge['formals'])
            bridge['args'] = ', '.join(re.sub(r'[^,]* (\w+)',
                                              r'\1',
                                              bridge['formals']).split(','))
            # If the bridge if "foo_vector", it's actually for a
            # variadic call.
            bridge['call'] = 'call_variadic' if reg.endswith('_vector') else 'call'
            if reg in bridges:
                raise RuntimeError("bridge multiply defined: " + reg)
            bridges[reg] = bridge

# Generate the header.
def header():
    res = r'''// Generated, do not edit by hand.

#pragma once

#include <vector>

#include <vcsn/algos/fwd.hh> // letter_class_t
#include <vcsn/core/rat/identities.hh> // rat::identities
#include <vcsn/dyn/fwd.hh> // dyn::automaton, etc.
#include <vcsn/misc/export.hh> // LIBVCSN_API
#include <vcsn/misc/fwd.hh> // signature
#include <vcsn/misc/name.hh> // integral_constant

namespace vcsn
{
  class automaton_editor;
}

namespace vcsn { namespace dyn { namespace detail {

#define REGISTER_DECLARE(Name, Signature)                       \
  using Name ## _t = auto Signature;                            \
  LIBVCSN_API                                                   \
  bool Name ## _register(const signature& sig, Name ## _t fn)

'''
    for f in sorted(bridges):
        res += register.format(**bridges[f])

    res += '''
#undef REGISTER_DECLARE
}}}'''
    return res

# Generate the implementation file.
def output():
    res = r'''// Generated, do not edit by hand.

#include <lib/vcsn/algos/registry.hh>
#include <vcsn/dyn/algos.hh>
#include <vcsn/dyn/automaton.hh>
#include <vcsn/dyn/context.hh>
#include <vcsn/dyn/expression.hh>
#include <vcsn/dyn/expansion.hh>
#include <vcsn/dyn/label.hh>
#include <vcsn/dyn/polynomial.hh>
#include <vcsn/dyn/weight.hh>
#include <vcsn/dyn/registers.hh>

namespace vcsn { namespace dyn {
'''
    for f in sorted(bridges):
        if f not in ['focus', 'focus_context',
                     'lift_automaton', 'lift_automaton_tape',
                     'read_polynomial', 'read_context',
                     'read_weight', 'read_label', 'read_automaton',
                     'read_expression', 'make_context', 'list_polynomial',
                     'print_polynomial', 'print_expansion', 'print_expression',
                     'print_weight', 'print_label']:
            res += implementation.format(**bridges[f])

    res += '''
}}'''

    return res


# Generate a function which, given an bridge name, returns the header
# that defined it.
def bridge():
    res = r'''// Generated, do not edit by hand.

#include <unordered_map>

#include <vcsn/dyn/context-printer.hh>

namespace vcsn { namespace ast {

  void context_printer::header_algo(const std::string& algo)
  {
    static auto headers
      = std::unordered_map<std::string, std::string>
        {
'''
    for f in sorted(bridges):
        res += '          {{ "{reg}", "{file}" }},\n'.format(**bridges[f])

    res += '''\
        };
    headers_late_.insert("vcsn/algos/" + headers.at(algo));
  }
}}'''

    return res




parser = argparse.ArgumentParser(description='Generate registers file.')
parser.add_argument('file', nargs='+', type=str, default=None,
                    help='Headers to process')
parser.add_argument('--bridge',
                    type=argparse.FileType('w'), default = '-',
                    help='bridge header finder file to generate')
parser.add_argument('--header',
                    type=argparse.FileType('w'), default = '-',
                    help='header file to generate')
parser.add_argument('--output',
                    type=argparse.FileType('w'), default = '-',
                    help='implementation file to generate')
parser.add_argument('-s', '--srcdir', type=str, default='.',
                    help='Path the the source tree')
args = parser.parse_args()
args.srcdir += '/'

for fn in args.file:
    process_file(args.srcdir + fn)

print(header(), file=args.header)
print(output(), file=args.output)
print(bridge(), file=args.bridge)
